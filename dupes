#!/usr/bin/env ruby
################################################################
require 'epitools'
require 'slop'
################################################################

class FakeOptions
  def method_missing(*args); nil; end
end

def parse_options
  Slop.parse(help: true, strict: true) do
    banner 'Usage: dupes [options] <files or dirs...>'

    on 'd',  'delete',      'Delete dupes (interactive by default)'
    on 'i',  'interactive', 'Interactively delete dupes'
    on 'e=', 'exclude',     'Exclude a path'
  end
end

################################################################

def common_prefix(files)
  x, *xs = files.map &:to_s

  x.each_char.with_index do |c, i|
    unless xs.all? { |s| s[i] == c }
      return x[0...i]
    end
  end

  ""
end

################################################################

args = ARGV

if args.empty? or args.any? { |opt| opt[/^-/] }
  opts = parse_options
else
  opts = FakeOptions.new
end

################################################################

args << "." if args.empty?  # Default is current dir

# Gather files
files = args.map do |arg|
  path = Path[arg]
  path.dir? ? path.ls_r.select(&:file?) : path
end.flatten

# Exclude patterns
if opts[:exclude]
  pattern = /#{Regexp.escape opts[:exclude]}/i
  files.reject! { |f| f =~ pattern }
end

# Get file sizes
sized_files = files.map { |f| [f.size, f] }.sort

$stderr.puts "* Found #{files.size} files..."

# Find duplicates
dupes = []
sized_files.each_cons(2) do |(s1,f1), (s2,f2)|
  if s1 == s2
    if f1.sha256 == f2.sha256
      dupes << [[s1,f1], [s2, f2]]
    end
  end
end

# That was easy!
if dupes.empty?
  $stdout.puts "No dupes!"
  exit 1
end

if opts.delete? or opts.interactive?
  # Interactively delete files
  deleter = Path.which("trsh", "rm").compact.first

  dupes.each do |(a,b)|

    prefix = common_prefix([a.last, b.last])

    [a,b].each_with_index do |(size, file), i|
      puts "<7>#{i+1}<8>) <9>#{size.commatize} <8>| <11>#{file.relative_to(prefix)}".colorize
    end

    # without_common_prefix([f1, f2]).each_with_index do |name, i|
    #   puts "#{i+1}) #{name}"
    # end

    print "which to delete? > "

    if (choice = $stdin.gets.strip).blank?
      puts "Skipping"
      puts
      next
    end

    unless file_to_delete = [a,b][choice.to_i-1]
      puts "Invalid choice."
      puts
      redo
    end

    cmd = [deleter, file_to_delete.last]
    p cmd.map(&:to_s)
    system *cmd

    puts
  end
else
  # Display dupes
  dupes.each do |a,b|
    [a,b].each do |size, file|
      puts "<9>#{size.commatize} <8>| <11>#{file.relative_to(Path.pwd)}".colorize
    end
    puts
  end
end

# if opts.delete?
#   puts "* Deleting dupes:"
#   grouped_dupes.each do |hash, dupes|
#     orig = dupes.pop
#     puts "* #{orig}"
#     dupes.each do |dupe|
#       puts "  |_ DELETE: #{dupe}"
#       File.unlink dupe
#     end
#   end
# end