#!/usr/bin/env ruby
gem 'slop', "~> 3.6"
require 'slop'
require 'epitools'

def copy(src, dest)
  open(src, "rb") do |input|
    open(dest, "wb") do |output|
      IO.copy_stream(input, output)
    end
  end
end

def parse_options
  opts = Slop.parse(help: true, strict: true) do
    banner "Usage: qemu [options] <.iso(s) or .qcow2 file(s) or /dev(s)>"

    on "m=", "memory",   "How much memory to use?", default: "2G"
    on "s=", "size",     "Disk size (you can also append this to the qcow2 filename, eg: 'zfspool.qcow2:30G')", default: "10G"  # TODO: Accept the size as a suffix to the .qcow2 filename (eg: freebsd.qcow2:10G)
    on "B",  "nbd",      "Attach image to a block device (for mounting filesystems)"
    on "d=", "device",   "Add a QEMU device (eg: rtl8139)"
    on "b=", "boot",     "Drive to boot (eg: --boot=a)"
    on "k=", "kvm",      "Use KVM", default: true
    on "p=", "port",     "Forward a port to the machine (eg: '22', or '2222:22')"
    on "P=", "cpus",     "Number of CPUs (default: 1)"
    on "B=", "bios",     "Load a BIOS ROM file"
    on "S=", "samba",    "Mount a host directory via samba (eg: --samba=/home/me/vmfiles) (the SMB mount will be on 10.x.x.4)"
    on "9=", "9p",       "Mount a host directory via 9p (eg: --9p=/home/me/guestshared)\n" +
                            "\tmount with:\n" +
                            "\t\tmount -t 9p host0 /mnt\n" +
                            "\tor add a line to the guest's fstab:\n" +
                            "\t\thost0 /wherever 9p trans=virtio,version=9p2000.L 0 0"
    on "r",  "restrict", "Restrict the network (firewall)"
    on "e",  "efi",      "Boot using OVMF EFI BIOS"
    on "1",  "pi",       "Raspberry PI mode"
    on "2",  "pi2",      "Raspberry PI 2 mode"
    on "t",  "serial",   "Print serial output to STDIO ('debug' mode)"
    on "c",  "console",  "STDIO-only serial console mode"
    on "C",  "curses",   "Terminal-based UI (Press Alt-2 to get to qemu command console)"
    on "n",  "no-daemon","Run in the foreground"
    # on "d",  "debug",    "Print command and quit"
    on "M",  "cursor",   "Show the mouse cursor"
    on "v",  "verbose",  "Show (a little) more information"
    on "V",  "version",  "Show version information"
    # on "b=", "backing-file",    "Use this as the backing file"
  end

  [opts, ARGV]
end

opts, args = parse_options

if opts.version?
  %w[qemu-system-x86_64 qemu-system-i386 qemu-system-arm qemu-img].any? do |bin|
    system(bin, "--version")
  end
  exit
end

if args.empty? and not opts.bios?
  puts opts
  exit 1
end

isos, disks = args.map { |arg| Path.new(arg) }.partition { |arg| arg.ext == "iso" or arg.path =~ %r{^/dev/s(r|cd)\d} }

missing_isos = isos.reject(&:exist?)
if missing_isos.any?
  missing_isos.each { |iso| puts "Error: #{iso.inspect} does not exist".light_red }
  exit 1
end

###############################
# Attach NBD
###############################
if opts.nbd?

  if Process.uid != 0
    puts "Error: You must run this as root."
    # exec("sudo", "ruby", __FILE__)
  else
    # TODO: Detect if an image (this image?) is already mounted
    # TODO: Prompt the user to disconnect a device if they're all full
    disks.each do |disk|
      dev = "/dev/nbd0"
      mnt = "/mnt"

      puts "[-] loading nbd kernel module"
      system("modprobe", "nbd", "max_part=8")

      puts "[-] connecting #{disk} to #{dev}"
      system("qemu-nbd", "--connect=#{dev}", disk)

      puts "[-] creating /devs #{disk} to #{dev}"
      system("partx", "-a", dev)

      puts "[!] done!"
      puts
      puts

      system("fdisk", "-l", dev)

      puts
      puts "(NOTE: You can run 'qemu-nbd --disconnect #{dev}' to disconnect the nbd from the disk image)"
      puts
      # p system("qemu-nbd", "--disconnect", dev)
    end

    isos.each do |iso|
      puts "Can't mount isos yet. Sorry!"
    end
  end

  exit
end


###############################
# Run QEMU
###############################

#
# RPI2 commands:
#
# qemu-system-arm -kernel kernel-qemu-3.10.25-wheezy 
# -initrd installer-rpi2-qemu.cpio 
# -cpu arm1176 -m 256 -M versatilepb 
# -no-reboot 
# -append "root=/dev/sda1 rw vga=normal console=ttyAMA0 console=ttyS0" 
# -hda raspbian-ua-netinst-v1.0.8.1.img
#
# qemu-system-arm.exe -M raspi2
# -kernel kernel-rpi2_install.img
# -sd raspbian-ua-netinst-v1.0.8.1-ready.img
# -append "rw earlyprintk loglevel=8 console=ttyAMA0,115200 console=ttyS0 root=/dev/mmcblk0p2"
# -monitor stdio
#

memory = opts[:memory]

if opts.pi?
  cmd = ["qemu-system-arm", "-cpu", "arm1176", "-M", "versatilepb"]
elsif opts.pi2?
  cmd = ["qemu-system-arm", "-cpu", "arm1176", "-M", "raspi2"]
else
  cmd = ["qemu-system-x86_64"]
  if File.exist?("/dev/kvm") or opts.kvm?
    cmd += ["-enable-kvm", "-cpu", "host"]
  else
    cmd += ["-cpu", "max"]
  end
end

if opts[:cpus]
  cmd += ["-smp", opts[:cpus]]
end

cmd += ["-rtc", "base=localtime"]
cmd += ["-m", memory]
cmd += ["-object", "rng-random,id=rando,filename=/dev/urandom"]

if opts.device?
  cmd += ["-device", opts[:device]]
end

if opts[:"9p"]
  path = Path[opts[:"9p"]]

  if path.file?
    puts "Error: #{path} is a file"
    exit 1
  end

  if not path.dir?
    puts "[+] Creating #{path}"
    path.mkdir_p
  end

  puts "[+] The contents of #{path} will be shared inside in the VM; make sure to 'mount -t 9p host0 /mnt' in the VM to access them"

  cmd += ["-virtfs", "local,path=#{path},mount_tag=host0,security_model=none,readonly=off,id=host0"] # security_model=mapped-xattr
end

if opts[:bios]
  cmd += ["-bios", opts[:bios]]

elsif opts.efi?
  places_to_look = %w[
    /usr/share/edk2-ovmf/x64
    /usr/share/ovmf/x64
  ]

  ovmf_bios = nil
  places_to_look.any? do |place|
    file = "#{place}/OVMF.fd"
    ovmf_bios = file if File.exist?(file)
  end

  raise "Error: OVMF.fd not found in #{places_to_look.map(&:inspect).join(" or ")}" unless ovmf_bios

  cmd += ["-bios", ovmf_bios]

  # bios = "#{place}/OVMF_CODE.fd"
  # if File.exist?(bios)
  #   readonly_vars = "#{place}/OVMF_VARS.fd"
  #   vars          = "/tmp/ovmf_vars.fd"

  #   raise "Error: #{bios} not found" unless File.exists?(bios)
  #   raise "Error: #{readonly_vars} not found" unless File.exists?(readonly_vars)

  #   copy(readonly_vars, vars)

  #   cmd += [
  #     "-drive", "if=pflash,format=raw,readonly=on,file=#{bios}",
  #     "-drive", "if=pflash,format=raw,readonly=on,file=#{readonly_vars}",
  #     "-drive", "if=pflash,format=raw,file=#{vars}"
  #   ]
end

if opts.console?
  # cmd += %w[-nographic -serial mon:stdio -append 'console=ttyS0']
  # cmd += %w[-nographic -serial mon:stdio]
  # cmd += %w[-nographic -device sga -serial mon:stdio]
  cmd += %w[-device sga -nographic -serial mon:stdio]
  # cmd += %w[-nographic -curses]
else
  cmd += ["-vga", "std"]
end

cmd << "-show-cursor" if opts.cursor?
cmd += ["-display", "curses"] if opts.curses?
cmd += ["-serial",  "stdio"]  if opts.serial?

disks.each do |disk|
  # parse out the :<size><units> option from the end of the file (eg: 'zfspool.qcow2:10G')
  if disk.filename =~ /^(.+):(\d+)([kmg]b?)$/i
    disk = disk.with(filename: $1)
    size = "#{$2}#{$3}"
  else
    size = opts[:size]
  end

  unless disk.exists?
    # Create a new disk
    case disk.ext
    when "qcow2"
      print "[+] "
      system("qemu-img", "create", "-f", "qcow2", disk, size)
    else
      puts "I don't know how to make a #{disk} image"
    end
  end

  # -drive file=/dev/sdd,format=raw,if=virtio
  driveopts = ["file=#{disk}"]
  driveopts << "format=raw" if (disk.ext == "img") or disk[%r{^/dev/.+}]

  cmd += ["-drive", driveopts.join(",")]
end

isos.each  { |iso| cmd += ["-cdrom", iso] }

# Networking
netopts = "user,id=usernet"
netopts += ",restrict=on" if opts.restrict?
netopts += ",smb=#{opts[:samba]}" if opts[:samba]

if port = opts[:port]
  src, dest = port.split(":")
  dest ||= src
  netopts += ",hostfwd=tcp::#{src}-:#{dest}"
end

cmd += ["-netdev", netopts]
cmd += ["-net", "nic,netdev=usernet"]
cmd += ["-boot", opts[:boot]] if opts[:boot]

p cmd if opts.verbose? or opts.debug?

unless opts.debug?
  Process.daemon(true) unless opts["no-daemon"] or opts.console? or opts.curses? or opts.serial?
  exec *cmd
end
