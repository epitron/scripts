#!/usr/bin/env ruby
###################################################
gem 'slop', "~> 3.6"
require 'slop'
require 'mimemagic'
require 'pathname'
###################################################

def parse_options
  opts = Slop.parse(help: true, strict: true) do
    banner "Usage: fixexts [options]"

    # on 'c',  'codecs',  'List the availiable codecs'
    # on 'u=', 'use',     'Tool to use (ffmpeg, mencoder)', default: "ffmpeg"
  end

  [opts, ARGV]
end

###################################################
#
# Prompt the user for confirmation.
#
# Usage:
#   prompt("Do you want a cookie?", "Ynqa") #=> returns the letter that the user pressed, in lowercase (and returns the default, 'y', if the user hits ENTER)
#

def prompt(message="Are you sure?", options="Yn")
  opts      = options.scan(/./)
  optstring = opts.join("/") # case maintained
  defaults  = opts.select{|o| o.upcase == o }
  opts      = opts.map{|o| o.downcase}

  raise "Error: Too many default values for the prompt: #{default.inspect}" if defaults.size > 1

  default = defaults.first

  loop do

    print "#{message} (#{optstring}) "

    response = STDIN.gets.strip.downcase

    case response
    when *opts
      return response
    when ""
      return default.downcase
    else
      puts "  |_ Invalid option: #{response.inspect}. Try again."
    end

  end
end

###################################################

def skipit?(ext, true_ext, mime)
  # p [ext, true_ext, mime]
  (ext == "apk"    and true_ext == "zip") or
  (ext == "xspf"   and true_ext == "htm") or
  (ext == "java"   and true_ext == "c") or
  (ext == "json"   and true_ext == "c") or
  (ext == "js"     and true_ext == "c") or
  (ext == "rdf"    and true_ext == "xml") or
  (ext == "mp4"    and true_ext == "3gpp") or
  (ext == "m4a"    and true_ext == "mp4") or
  (ext == "m4a"    and true_ext == "3gpp") or
  (ext == "docx"   and true_ext == "zip") or
  (ext == "html"   and true_ext == "xht") or
  (ext == "htm"    and true_ext == "xht") or
  (ext == "m4a"    and true_ext == "3ga") or
  (ext == "dll"    and true_ext == "exe") or
  (ext == "mhtml"  and true_ext == "eml") or
  (ext == "sketch" and true_ext == "sqlite3") or
  (ext == ""       and mime.type =~ /(^application|python3?$)/) or
  (ext =~ /^(ppt|pps|xls)$/ and mime.type == "application/x-ole-storage") or
  false
end

def fix!(path)
  mime = path.open { |io| MimeMagic.by_magic(io) }
  return unless mime

  ext      = path.extname.downcase.gsub(/^\./, '')
  true_ext = mime.extensions.first

  unless mime.extensions.include?(ext)
    return if skipit?(ext, true_ext, mime)

    msg = "* #{path} is actually a \".#{true_ext}\" (#{mime.type}); rename?"
    if prompt(msg) == "y"
      newpath = path.sub_ext(".#{true_ext}")
      puts "  |_ #{path} => #{newpath}"
      path.rename(newpath)
    end
  end
end

###################################################

opts, args = parse_options
args << "." if args.empty?

paths = args.map { |arg| Pathname.new(arg) }

paths.each do |path|
  p path
  if path.directory?
    puts "Scanning #{path.to_s == "." ? "current directory" : path.inspect }"
    path.find { |entry| fix!(entry) if entry.file? and not entry.dirname.to_s[%r{(^|/)\.git(/|$)}] }
  else
    fix!(path)
  end
end
