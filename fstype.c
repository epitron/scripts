#include <sys/vfs.h>
#include <stdio.h>

#define ARRAY_LEN(a) (sizeof(a) / sizeof((a)[0]))

/*
This list is generated by doing search and replace on the output from `man statfs`

Here's the Regex I used:
  ^\s+(\w+?)(?:_SUPER)?_MAGIC(?:\w+)?\s+(\w+) =>  { "\1", \2 },

Some can also be gotten from /usr/include/linux/magic.h:
  #define (\w+)(?:_SUPER)?_MAGIC(?:\w+)?\s+(\w+) => { "\1", \2 },
*/

static const struct {
        const char *name;
        unsigned int f_type;
} FSTypes[] = {
  { "ADFS", 0xadf5 },
  { "AFFS", 0xadff },
  { "AFS", 0x5346414f },
  { "ANON_INODE_FS", 0x09041934 }, /* Anonymous inode FS */
  { "AUTOFS", 0x0187 },
  { "BDEVFS", 0x62646576 },
  { "BEFS", 0x42465331 },
  { "BFS", 0x1badface },
  { "BINFMTFS", 0x42494e4d },
  { "BPF_FS", 0xcafe4a11 },
  { "BTRFS", 0x9123683e },
  { "BTRFS_TEST", 0x73727279 },
  { "CGROUP", 0x27e0eb },   /* Cgroup pseudo FS */
  { "CGROUP2", 0x63677270 }, /* Cgroup v2 pseudo FS */
  { "CIFS", 0xff534d42 },
  { "CODA", 0x73757245 },
  { "COH", 0x012ff7b7 },
  { "CRAMFS", 0x28cd3d45 },
  { "DEBUGFS", 0x64626720 },
  { "DEVFS", 0x1373 },     /* Linux 2.6.17 and earlier */
  { "DEVPTS", 0x1cd1 },
  { "ECRYPTFS", 0xf15f },
  { "EFIVARFS", 0xde5e81e4 },
  { "EFS", 0x00414a53 },
  { "EXT", 0x137d },     /* Linux 2.0 and earlier */
  { "EXT2_OLD", 0xef51 },
  { "EXT2", 0xef53 },
  { "EXT3", 0xef53 },
  { "EXT4", 0xef53 },
  { "F2FS", 0xf2f52010 },
  { "FUSE", 0x65735546 },
  { "FUTEXFS", 0xbad1dea },  /* Unused */
  { "HFS", 0x4244 },
  { "HOSTFS", 0x00c0ffee },
  { "HPFS", 0xf995e849 },
  { "HUGETLBFS", 0x958458f6 },
  { "ISOFS", 0x9660 },
  { "JFFS2", 0x72b6 },
  { "JFS", 0x3153464a },
  { "MINIX", 0x137f },     /* original minix FS */
  { "MINIX", 0x138f },     /* 30 char minix FS */
  { "MINIX2", 0x2468 },     /* minix V2 FS */
  { "MINIX2", 0x2478 },     /* minix V2 FS, 30 char names */
  { "MINIX3", 0x4d5a },     /* minix V3 FS, 60 char names */
  { "MQUEUE", 0x19800202 }, /* POSIX message queue FS */
  { "MSDOS", 0x4d44 },
  { "MTD_INODE_FS", 0x11307854 },
  { "NCP", 0x564c },
  { "NFS", 0x6969 },
  { "NILFS", 0x3434 },
  { "NSFS", 0x6e736673 },
  { "NTFS_SB", 0x5346544e },
  { "OCFS2", 0x7461636f },
  { "OPENPROM", 0x9fa1 },
  { "OVERLAYFS", 0x794c7630 },
  { "PIPEFS", 0x50495045 },
  { "PROC", 0x9fa0 },     /* /proc FS */
  { "PSTOREFS", 0x6165676c },
  { "QNX4", 0x002f },
  { "QNX6", 0x68191122 },
  { "RAMFS", 0x858458f6 },
  { "REISERFS", 0x52654973 },
  { "ROMFS", 0x7275 },
  { "SECURITYFS", 0x73636673 },
  { "SELINUX", 0xf97cff8c },
  { "SMACK", 0x43415d53 },
  { "SMB", 0x517b },
  { "SMB2", 0xfe534d42 },
  { "SOCKFS", 0x534f434b },
  { "SQUASHFS", 0x73717368 },
  { "SYSFS", 0x62656572 },
  { "SYSV2", 0x012ff7b6 },
  { "SYSV4", 0x012ff7b5 },
  { "TMPFS", 0x01021994 },
  { "TRACEFS", 0x74726163 },
  { "UDF", 0x15013346 },
  { "UFS", 0x00011954 },
  { "USBDEVICE", 0x9fa2 },
  { "V9FS", 0x01021997 },
  { "VXFS", 0xa501fcf5 },
  { "XENFS", 0xabba1974 },
  { "XENIX", 0x012ff7b4 },
  { "XFS", 0x58465342 },
};

const char* lookup_fs_name(unsigned int f_type) {
  for (int i = 0; i < ARRAY_LEN(FSTypes); i++)
    if (FSTypes[i].f_type == f_type)
      return FSTypes[i].name;
  return NULL;
}

int main(int argc, char* argv[]) {
  struct statfs buf;
  char* path;
  const char* fsname;

  if (argc < 2) {
    printf(
      "usage:\n"
      "  %s <path(s) to any mounted filesystem(s)>\n"
      "\n"
      "purpose:\n"
      "  Print the VFS f_type of the specified paths (using statfs(3))\n"
      "\n", argv[0]);
    return 1;
  }

  for (int i = 1; i < argc; i++) {
    path = argv[i];

    statfs(path, &buf);
    fsname = lookup_fs_name(buf.f_type);

    if (fsname == NULL)
      fsname = "unknown";

    printf("%s: %s (0x%x)\n", path, fsname, buf.f_type);
  }

  return 0;
}


