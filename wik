#!/usr/bin/env ruby
######################################################################
require 'epitools'
gem 'slop', "~> 3.6"
require 'slop'
######################################################################

class String
  def smash
    downcase.scan(/\w+/).join
  end
end

######################################################################
#
# Markdown to ANSI Renderer ("BlackCarpet")
#
# This class takes a little while to initialize, so instead of slowing down the script for every non-markdown file,
# I've wrapped it in a proc which gets lazily loaded by `render_markdown` when needed.
#

BLACKCARPET_INIT = proc do

  def indented?(text)
    indent_sizes = text.lines.map{ |line| if line =~ /^(\s+)/ then $1 else '' end }.map(&:size)
    indent_sizes.all? {|dent| dent > 0 }
  end

  def unwrap(text)
    return text unless indented? text
    text.lines.to_a.map(&:strip).join ' '
  end

  def indent(text,amount=2)
    text.lines.map{|line| " "*amount + line }.join
  end

  class BlackCarpet < Redcarpet::Render::Base

    def normal_text(text)
      text
    end

    def raw_html(html)
      ''
    end

    def link(link, title, content)
      unless content&.[] /^Back /
        str = ""
        str += "<15>#{content}</15>" if content
        if title
          if title.smash != content.smash
            str += " <8>(</8><11>#{title}</11><8>)</8>"
          end
        elsif link
          str += " <8>(</8><9>#{link}</9><8>)</8>"
        end

        str.colorize
      end
    end

    def block_code(code, language)
      language ||= :ruby
      language = :cpp if language == "C++"
      require 'coderay'
      "#{indent CodeRay.scan(code, language).term, 4}\n"
    end

    def block_quote(text)
      indent paragraph(text)
    end

    def codespan(code)
      code.cyan
    end

    def header(title, level, anchor=nil)
      color = case level
        when 1 then :light_yellow
        when 2 then :light_cyan
        when 3 then :light_blue
        else :purple
      end

      bar = ("-"*(title.size+4)).grey

      "#{bar}\n  #{title.send(color)}\n#{bar}\n\n"
    end

    def double_emphasis(text)
      text.light_green
    end

    def emphasis(text)
      text.green
    end

    def linebreak
      "\n"
    end

    def paragraph(text)
      "#{indented?(text) ? text : unwrap(text)}\n\n"
    end

    def list(content, list_type)
      case list_type
      when :ordered
        @counter = 0
        "#{content}\n"
      when :unordered
        "#{content}\n"
      end
    end

    def list_item(content, list_type)
      case list_type
      when :ordered
        @counter ||= 0
        @counter += 1
        "  <8>#{@counter}.</8> #{content.strip}\n".colorize
      when :unordered
        "  <8>*</8> #{content.strip}\n".colorize
      end
    end

    def table_cell(content, alignment)
      @cells ||= []
      @cells << content

      content
    end

    def table_row(content)
      @rows ||= []

      if @cells
        @rows << @cells.dup
        @cells.clear
      else
        @rows << []
      end

      content
    end

    def table(header, body)
      headings = @rows.shift
      table    = Terminal::Table.new(headings: headings, rows: @rows)
      @rows    = []

      "#{table}\n\n"
    end
  end

  BlackCarpet
end

######################################################################

def markdown_to_ansi(markdown)
  require 'redcarpet'

  BLACKCARPET_INIT.call unless defined? BlackCarpet

  options = {
    no_intra_emphasis: true,
    fenced_code_blocks: true,
  }

  begin
    require 'terminal-table'
    carpet = Redcarpet::Markdown.new(BlackCarpet, options.merge(tables: true))
  rescue LoadError
    carpet = Redcarpet::Markdown.new(BlackCarpet, options)
  end

  carpet.render(markdown)
end

######################################################################

class Article < Struct.new(:wiki, :title, :id, :type, :redirect_id, :namespace)

  TYPES = {
    "R" => :redirect,
    "A" => :article,
  }

  def self.from_line(wiki, line)
    namespace, file, title, id, type_char, redirect_id, size = line.split("\t")
    new(wiki, title, id, TYPES[type_char], redirect_id, namespace)
  end

  def article?
    type == :article
  end

  def redirect?
    type == :redirect
  end

  def body
    the_id = redirect? ? redirect_id : id
    cmd = ["zimdump", "-o", the_id, "-d", wiki.file]
    IO.popen(cmd, "r") { |io| io.read }
  end

end

######################################################################

class Wiki

  attr_reader :file

  def initialize(file)
    @file = file
  end

  def index
    @index ||= Index.new(self, "wik.index")
  end

  def get(id)
    cmd = ["zimdump", "-o", id, "-i", file]
    hash = IO.popen(cmd, "r") do |io|
      # url: 1817_in_the_UK.html
      #   title:           1817 in the UK
      #   idx:             61488
      #   namespace:       A
      #   type:            redirect
      #   redirect index:  61489
      io.each_line.map { |l| l.scan(/\s*([^:]+):\s+(.+)/) }.flatten(1).to_h
    end

    # Article < Struct.new(:wiki, :title, :id, :type, :redirect, :namespace)
    Article.new self, *hash.values_at("title", "idx", "type", "redirect index", "namespace")
  end

  def zimdump_search_crappy(words, max_results=100)
    cmd = ["zimdump", "-f", words.join(" "), "-L", @file]
    lines = IO.popen(cmd, "r") { |io| io.each_line.take(max_results) }
    lines.map { |line| Article.from_line(self, line) }
  end

  def tsv_search(words, max_results=100)
    regex = /#{words.join(".*")}/i
    cmd = ["grep", "-E", "#{words.join(".*")}", Path["~/kiwix-index.tsv"].to_s]
    IO.popen(cmd) do |io|
      io.each_line.map { |line| Article.from_line(self, line) }.select &:article?
    end
  end

  def zimdump_search(words, max_results=100)
    regex   = /#{words.join(".*")}/i
    cmd     = ["zimdump", "-f", words.first, "-L", @file]
    matches = []

    IO.popen(cmd, "r") do |io|
      io.each_line.with_spinner.with_index do |line, i|
        article = Article.from_line(self, line)
        # p article.title

        # if article.title[0...words.first.size] > words.first
        #   p breaking_at: article.title
        #   break
        # end

        matches << article if article.title[regex]

        break if i > max_results and not matches.empty?
        break if i > max_results*2
        break if matches.size >= max_results
      end
    end
    matches
  end

  def search(words, max=50)
    index.search(words, max)
  end

  def each_article
    cmd = ["zimdump", "-n", "A", "-L", file]
    IO.popen(cmd, "r") do |io|
      io.each_line { |line| yield Article.from_line(self, line) }
    end
  end

end

######################################################################

require 'sequel'

class Index

  attr_reader :db, :wiki

  def initialize(wiki, file)
    @wiki = wiki
    @db = Sequel.sqlite(file)
  end

  def search(words, max=50)
    query = "%#{words.join("%")}%"
    db[:titles].where { title.like query }.limit(max)
  end

  def rebuild!
    puts "* Creating table..."
    db.create_table!(:titles) do
      column :title, :text
      column :article_id, :string
    end

    titles = db[:titles]

    puts "* Adding articles..."

    wiki.each_article do |article|
      puts "|_ #{article.title}"
      titles.insert(article.title, article.id)
    end

    puts "* Indexing..."
    db.alter_table(:titles) { add_index :title }
  end

end

######################################################################

WEBSERVER = proc do |wiki|
  $wiki = wiki

  require 'sinatra/base'

  class WebServer < Sinatra::Base
    get "/I/(.+)" do
      # /I/m/American_Samoa_location_map.svg.png

    end

    get "/:id" do
      article = $wiki.get(params["id"])

      article.body
    end

    get "/" do

      p :searching

      if query = params["q"]
        results = $wiki.zimdump_search(query.split, 50)
      end

      haml %{
%form
  %p Search:
  %input{name: 'q'}
  %input{type: 'submit'}

%code= params

%ul
  - results.each do |result|
    %li
      %a{href: "/" + result.id}= result.title
      }, {}, {results: results}

    end

    run!
  end
end

######################################################################
# Parse options
######################################################################

opts = Slop.parse(help: true, strict: true) do
  banner "Usage: wik [options] <search terms>"

  on "s",   "server",       "Start server"
  on "i",   "index",        "Rebuild index"
  on "n=",  "num-results",  "Number of results", default: 10
end

args = ARGV

######################################################################

if __FILE__ == $0

  wikipath = Path["~/kiwix/data/content/wikipedia_en_all_2016-12.zim"]

  # Webserver
  if opts.server?
    WEBSERVER.call(Wiki.new(wikipath))
    exit
  end

  # Regenerate Index
  if opts.index?
    w.index.rebuild!
    exit
  end


  if args.empty?
    puts
    puts "Error: Must supply at least one search term".light_red
    puts
    puts opts
    exit 1
  end

  w = Wiki.new(wikipath)

  query   = args.join " "
  results = w.tsv_search(args, opts[:n].to_i)
  # results = w.zimdump_search(args, opts[:n].to_i)

  colorized_results = results.map.with_index do |result, n|
    highlighted_title = result[:title].gsub(query) { |m| "<14>#{m}</14>" }
    "<7>#{n+1}<8>. <11>#{highlighted_title}".colorize
  end

  puts Term::Table.new(colorized_results, :ansi=>true).by_columns

  print "<8>select> <7>".colorize

  n = $stdin.gets.to_i
  article = results[n-1]
  # article = results.first

  ansi = IO.popen("html2text", "r+") do |markdown|
    markdown.write article.body
    markdown.close_write
    markdown_to_ansi(markdown.read)
  end

  lesspipe { |less| less.puts ansi }

end